# 正则表达式

## 1.正则表达式的定义

- 直接量

  ```js
  var pattern = /s$/
  ```

- 构造函数

```js
var pattern = new RegExp("s$")
```

RegExp直接量和对象的创建

程序运行时每次遇到对象直接量(初始化表达式)注入{}和[]的创建的时候都会创建新对象。比如在循环体中写

var a = [],则每次遍历都会创建一个新的空数组。

正则表达式直接量与此不同，ES3规定正则表达式直接量会在执行到它是转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回用一个对象。

ES5规定同一段代码所表示正则表达式直接量的每次运算都返回新对象。

多数版本采用ES5

问题：Firefox3.6和Firefox4+中运行结果不一致

```js
function getRE(){
    var re = /[a-z]/;
    re.foo = "bar";
    return re;
}

var reg = getRE();
re2 = getRE();
console.log(reg === re2);		//Firefox3.6返回true，Firefox4+返回false
reg.foo = "baz";
console.log(re2.foo);			//Firefox3.6返回"baz"，Firefox4+返回"bar"
```

## 2.直接量字符

| 值             | 匹配                                                |
| -------------- | --------------------------------------------------- |
| 字符和数字字符 | 自身                                                |
| \o             | NUL字符(\u0000)                                     |
| \t             | 制表符(\u0009)                                      |
| \n             | 换行符(\u000A)                                      |
| \v             | 垂直制表符(\u000B)                                  |
| \f             | 换页符(\u000C)                                      |
| \r             | 回车符(\u000D)                                      |
| \xnn           | 由十六进制数nn执行的拉丁字符，例如,\x0A等价于\n     |
| \uxxxx         | 十六进制数xxxx指定的Unicode字符，例如\u0009等价于\t |
| \cX            | 控制字符^X,例如,\cJ等价于换行符\n                   |
##3.字符类

| 值     | 匹配                                            |
| ------ | ----------------------------------------------- |
| [...]  | 方括号内的任意字符                              |
| [^...] | 不在方括号内的任意字符                          |
| .      | 除换行符和其他Unicode行终止符之外的任意字符     |
| \w     | 任何ASCLL字符组成的单词，等价于[a-z0-9A-Z]      |
| \W     | 任何不是ASCLL字符组成的单词，等价于[^a-z0-9A-Z] |
| \s     | 任何Unicode空白符                               |
| \S     | 任何非Unicode空白符的字符，注意和\w和\S不同     |
| \d     | 任何ASCLL数字，等价于[0-9]                      |
| \D     | 除了ASCLL数字之外的任何数字，等价于[^0-9]       |
| [\b]   | 退格直接量                                      |

##4.重复

| 值    | 含义                                                    |
| ----- | ------------------------------------------------------- |
| {n,m} | 匹配前一项至少n次，但不能超过m次                        |
| {n,}  | 匹配前一项n次或者更多次                                 |
| {n}   | 匹配前一项n次                                           |
| ?     | 匹配前一项0次或1次，也就是说前一项是可选的，等价于{0,1} |
| +     | 匹配前一项1次或多次，等价于{1,}                         |
| *     | 匹配前一项0次或多次，等价于{0,}                         |

非贪婪重复

上述表格中匹配都是尽可能多地匹配，只需在待匹配的字符后跟随一个问号即可："??","+?"等，尽可能少配

如"aaa"作为匹配字符串，表达式/a+?/匹配第一个a，而/a+/匹配三个a。

注意：正则表达式匹配是总会寻找字符串第一个可能匹配的位置。这里就不会匹配子串更短的匹配

例如：匹配字符/aaab/,表达式/a+?b/你期望匹配一个阿和最后一个b，但实际上匹配了整个字符串

##5.选择，分组，引用

选择项的选择匹配次序从左至右，知道发现匹配项

圆括号作用：

- 把单独的项组合成子表达式，以便处理一个单独单元

  ```js
  /java(script)/;			//可以匹配“java”，其后可以有“script”也可以没有
  /(ad|cd)+|ef/;			//可以匹配字符串“cf”，也可以匹配字符串“ab”或“cd”的一次或多次重复
  ```

  

- 在完整模式中第一子模式

  ```js
  /[a-z]+(\d+)/;			//可以检索到匹配中抽取数字了
  ```

- 在同一正则表达式的后部引用前面的子表达式。

  ```js
  /['"][^'"]*['"]/;
  /(['"])['"]*\1/;		//两个式子效果一致
  ```

  | 字符    | 含义                                                         |
  | ------- | ------------------------------------------------------------ |
  | \|      | 选择，匹配的是该符号左边的表达式或右边的子表达式             |
  | (..)    | 组合，将几个项组合为一个单元，这个单元可通过“*”，“+”，“？”和‘\|“等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供以后的引用使用 |
  | (?:...) | 只组合，把项组合到一个单元，但不记忆与该数组的相匹配的数组   |
  | \n      | 和第n个分组第一个匹配的字符相匹配，组是圆括号中的子表达式（也可能是嵌套的），组索引是从左至右的左括号数，”（？：“形式的分组不编码 |

## 6.指定匹配位置

  正则表达式中的锚字符

| 字符  | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| ^     | 匹配字符串的开头，在多行检索中，匹配一行的开头               |
| $     | 匹配字符串的结尾，在多行检索中，匹配一行的结尾               |
| \b    | 匹配一个单词的边界，简言之，就是位于字符\w和\W之间的位置，或位于字符\w和字符串的开头或结尾之间的位置,但需要注意的是，([\b]匹配的是退格符) |
| \B    | 匹配非单词边界的位置                                         |
| (?=p) | 零宽正向先行断言，要求接下来的字符都与p匹配，但不能包括匹配p的那些字符 |
| (?!p) | 零宽正向先行断言，要求接下来的字符不与p匹配                  |

## 7.修饰符

| 字符 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| i    | 执行不区分大小写的匹配                                       |
| g    | 执行一个全局匹配，简言之，即找到所有的匹配，而不是在找到第一个之后就停止 |
| m    | 多行匹配模式，^匹配一行的开头和字符串开头，$匹配行的技术和字符串结束 |

## 8.用于模式匹配的String方法

search():参数是一个正则表达式，返回第一个与之匹配的子串的起始位置，如果找不到匹配的子串，它将返回-1

```js
"JavaScript".search(/script/i);		//返回值为4
```

replace():第一参数是一个正则表达式，第二个参数是要进行替换的字符串。如果在替换的字符串中出现了$加数字，那么replace()将用于指定的子表达式相匹配的文本来替换这两个字符；replace()的第二个参数也能是函数

```js
//将所有不区分大小写的javascript都替换成大小写正确的JavaScript
text.replace(/javascript/gi,"JavaScript");
//一段引用文本起始于引号，结束于引号
//中间内容区域不能包含引号
var quote = /"([^"]"/g);
//用中文半角引号替代英文引号，同时保持引号之间的内容(存储在$1中)没有被修改
text.replace(quote,'“$1”');
```

match()：参数正则表达式，返回一个由匹配结果组成的的数组，如果没有修饰g，则不会全局检索，a[0]存放的是完整的匹配,a[1]存放的则是第一个圆括号括起来的表达式向匹配的子串

```js
"1 plus 2 equals 3".match(/\d+/g);		//返回["1","2","3"]
var url = /(\w+):\/\/([\w.]+)\/(\S*)/;
var text = "Visit my blog at http://www.example.com/~david";
var result = text.match(url);
if(result != null){
    var fullurl = result[0];		//"http://www.example.com/~david"
    var protocol = resulte[1];		//"http"
    var host = result[2];			//"www.example.com"
    var path = resulte[3];			//"~david"
}
```

split();参数正则表达式，返回一个子串组成的数组

```js
"123,456,789"split(",");			//返回["123","456","789"]
"1, 2, 3, 4, 5".split(/\s*,\s*/);	//返回["1","2","3","4","5"]
```

## 9.RegExp对象

构造函数有两个参数，第一个包含正则表达式的主体部分，第二个参数可选，为正则表达式的修饰符

```js
//全局匹配字符串中的5个数字，注意这里使用了"\\"，而不是"\"
var zipcode = new RegExp("\\d{5}","g")
```

RegExp属性

source:一个只读字符串，包含正则表达式的主题部分

global:一个只读布尔值，说明正则表达式是否带有修饰符g

ignoreCase:一个只读布尔值，说明正则表达式是否带有修饰符i

multiline:一个只读布尔值，说明正则表达式是否带有修饰符m

lastIndex:可读/写的整数，储存下一个字符串检索的开始位置

方法

exec()

参数是一个字符串。含有属性index表示包含了发生匹配的字符位置，属性input表示正在检索的字符串

和match不同，当它的全局正则表达式是，它返回匹配结果组成的数组。exec返回一个匹配结果，并提供本次的匹配的完整信息

text()

参数是一个字符串，用于某个字符串进行检测，如果包含正则表达式的一个匹配结果，则返回true

```js
var pattern = /Java/g;
var text = "JavaScript is more fun than Java";
var result
while((result = pattern.exec(text)) != null){
    alert("Matched '" + resulte[0] + "'" +
         " at position " + result.index + 
         "; next search begins at " + pattern.lastIndex);
}

var pattern2 = /java/i;
pattern.test("JavaScript");		//返回true
```

